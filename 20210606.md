# 参赛作品开发流水账
有关比赛的记录放在[这个文件夹里](https://github.com/slippingccaatt/summary/tree/master/%E5%8F%82%E8%B5%9B%E4%BD%9C%E5%93%81%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95)。

2021.05.24<br>
1. 写完了技能对接技能树的说明文档[]()

2021.05.25<br>
1. 正在做玩家的状态机。<br>
2. 决定把之前的想出来的“弹反子弹”作为玩家一开始就有的能力，使得游戏更具技巧性。设计新技能“飞剑”以填补该技能的空缺。

2021.05.26
1. 合作修对方的bug太难了，修两小时效率极低，我的血压上来了。
2. VScode的代码补全出了点问题。

2021.05.27
1. 代码控制“飞剑”运动，几经修改，运动变化仍达不到预期。查阅资料后，得以实现，但无法理解其核心代码：

    transform.position += transform.up * speed * Time.deltaTime;//千万别删这行，删了就没那效果了

飞剑技能效果如图：<br>
![SummonSword](https://github.com/slippingccaatt/summary/blob/master/%E5%8F%82%E8%B5%9B%E4%BD%9C%E5%93%81%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/%E5%9B%BE%E5%BA%93/SummonSword.gif)

2. 由于S君未来十天有事，未来十天不能开发，技能树的deadline被迫向后顺延到6月11日。
3. 由于时间规划的调整，技能树开发阶段的收尾工作向后顺延。在我完成该阶段的任务后，直接开始开发Enemy。
5. 修改了任务分工，S君做player完整的动画机和三个技能，我做剩下五个技能。

2021.05.28
1. 人物的状态机不做完，有些技能还没法做。为此修改了任务分工，S君做和三个技能，我做player的状态机剩下五个技能。
2. 清算

*******************

# 20210525-基于对象池的残影拖尾效果

## 目标
当美术素材较少时，我们可以基于对象池来实现残影拖尾效果，增强游戏的画面表现。

## 基本思路

步骤1. 创建一个2DSprite，编辑该对象的Image，使其为我们所需要的拖尾图片。

步骤2. 写一个方法，**使该对象Image-Color中的alpha通道值在指定时间内逐渐变小**，即图片逐渐变透明。

步骤3. 把该对象作为prefab，放入对象池。需要时，访问对象池。

## 相关代码
以下代码挂载在该对象的prefab上

    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class Trail : MonoBehaviour
    {
        private Transform tailTrans;
        private SpriteRenderer tailSprite;
        private SpriteRenderer thisSprite;
        private Color tailColor;
        private float showTimePoint;//时间点
        public float showTime = 0.3f;//时间段
        public float alphaMax = 0.5f;
        public float alphaMin = 0f;
        private float timer = 0f;

        private void OnEnable()
        {
            showTimePoint = Time.time;
            timer = 0f;

            //复刻player的动作，位置，转动，大小
            tailTrans = GameObject.FindGameObjectWithTag("Player").GetComponent<Transform>();
            tailSprite = GameObject.FindGameObjectWithTag("Player").GetComponent<SpriteRenderer>();
            thisSprite = GetComponent<SpriteRenderer>();

            thisSprite.sprite = tailSprite.sprite;
            transform.position = tailTrans.position;
            transform.rotation = tailTrans.rotation;
            transform.localScale = tailTrans.localScale;
        }

        private void FixedUpdate()
        {
            Timer(showTime);

            thisSprite.color = new Color(1 , 1 , 1 , Mathf.Lerp(alphaMax , alphaMin , timer));

            //时间到了，放回池子
            if(Time.time >= showTimePoint + showTime)
            {
                gameObject.transform.parent.gameObject.GetComponent<DictionaryTest>().BackToPool(this.gameObject);
            }
        }

        private void Timer(float showTime)
        {
            float _mult = 1 / showTime;

            if((timer += Time.deltaTime * _mult) <= 1f)
            {
                timer += Time.deltaTime * _mult;
            }
            else 
            {
                timer = 1f;
            }
        }
    }

## 最终效果
![image](https://img2020.cnblogs.com/blog/2346211/202105/2346211-20210525191452512-1964405313.gif)

## 补充
另外，只需调整预设图片，就能实现大部分简单的拖尾效果。

**************

# 20210528-清算以往问题，制定新的目标

## 前言
开发参赛作品前制定了相关计划。然而这份计划问题很大，现在清算。

## 问题

### 1.作品的最终质量无人把握

在之前的计划中，对于作品最终的样貌，只有一个大概的轮廓。**最后要做成什么样子，团队里没有人清楚**。

### 2.开发进度的规划脱离实际

之前的计划没有考虑“团队成员在何时有空”。在规划开发进度时，有必要且必须把这一点考虑进来。

然而常常会有紧急事件挤占开发时间，比如“考试”等，更何况有些紧急事件无法预测。

**规划进度时，我们应当更加宽容一些，但要注意这不是摸鱼的理由**。

### 3.分工问题 & 游戏模块对接问题

在之前的计划中，我们把主要游戏模块划分为“玩家的基本操控”、“技能树”、“敌人的行动”、“与要保护目标之间的交互”。

在开发技能时，这个问题就暴露出来了：**当两人同做一个模块时，如果该模块与其他模块的对接方法不清晰，则开发效率极低**。

## 清算

按照如下方法清算以上问题。

### 1.选定负责人

作为负责人，需要做：
1. 在与成员讨论后，撰写文档，清楚地说明游戏的需求，包括但不限于“玩家如何操作”、“画面如何表现”、“敌人如何行动”

，这份说明应当清楚到每个小细节。**对于非创新的游戏模块**，必须**量化**该模块的最终质量，**即对标成熟的同类型游戏**，使其具有可比性。

2. 写完文档后，团队中的所有成员都要查看该文档，并且询问相关的任何细节，负责人必须明确地解答，并且把回答记录在文档中。

3. 在游戏demo初步完成时，按照所撰写的文档，找出存在的问题或不足。

4. 在比赛报名最后期限的前五天，按照所撰写的文档，评估游戏质量。若质量达不到标准，则不参加比赛，继续打磨作品。

### 2.放宽时间预期

在规划进度时，要综合考虑成员的技术水平、空余时间、工作效率等情况。但这难以量化。

若时间短，任务重，则经常会追求“快速实现”，这容易给后续的开发和模块拓展造成麻烦。不如放宽时间好好打磨作品。

### 3.按照依赖度低的模块分工 & 清晰地说明对接方法

比如说，“UI界面”和“游戏场景”依赖度低，就可以分别给两个人做；而“玩家输入”和“角色状态机”依赖度高，就让同一个人来做。
如果非得两个人同做一个模块，需要在写代码前讨论好如何去做。

在开发某一模块之前，应当讨论并解决“该模块如何对接其他模块”的问题。

## 决定
1. 这个作品由我负责在七月底的报名截止前，如果游戏demo基本完成，我会评估demo质量，如果质量达到预期，则参赛；否则不参赛。
2. 虽然时间短，任务重，但还是尽力做，看能做到什么程度。
3. 若不参赛，则继续开发作品。预期在半年到一年内完成，一边打磨一边等待时机。